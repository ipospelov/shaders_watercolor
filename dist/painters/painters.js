class NestedPainter{constructor(){this.nCurrent=0,this.painters=[]}draw(){return this.nCurrent>=this.painters.length?0:(this.painters[this.nCurrent].draw()||this.nCurrent++,1)}}class FlowPainter{constructor(){this.noise=new NoiseCache(2e-4,0),this.xStart=xBufferSize/2-600,this.yStart=1e3,this.xCurrent=this.xStart,this.yCurrent=this.yStart,this.xStep=30,this.r=100,this.rStep=100,this.numYMax=17,this.numXMax=15,this.numYCurrent=0,this.numXCurrent=0,this.seed=fxrand()}draw(){if(this.numXCurrent>=this.numXMax)return 0;this.numYCurrent>=this.numYMax&&(this.xStart+=this.xStep,this.xCurrent=this.xStart,this.yCurrent=this.yStart,this.numYCurrent=0,this.numXCurrent++);var t=this.noise.get(this.xCurrent,this.yCurrent),r=map(t,0,1,0,Math.PI);let s=this.xCurrent+this.r*Math.cos(r),i=this.yCurrent+this.r*Math.sin(r);drawCurve(this.xCurrent,this.yCurrent,s,i,...palettes[0][1],{u_amplitude:.5,u_frequency:50,u_fbm_n:3,u_fbm_frequency:2,u_fbm_amplitude:.15});let n=this.rStep;return this.xCurrent=s+n*Math.cos(r),this.yCurrent=i+n*Math.sin(r),this.numYCurrent++,1}}class WavePainter{constructor(t,r,s,i,n,e){Object.assign(this,{y:t,n:i,colors:n,uniforms:e}),this.currentN=0,this.xMargin=150,this.hShift=Math.tan(s)*(xBufferSize/2+this.xMargin),this.hStep=r/max(1,i-1),this.nEachMax=0,this.nEachCurrent=0}getColor(){return this.colors[this.currentN%this.colors.length]}draw(){if(this.currentN>=this.n)return 0;let t=this.y-this.currentN*this.hStep;return drawWave(-this.xMargin,t-this.hShift,xBufferSize+this.xMargin,t+this.hShift,...this.getColor(),this.uniforms),this.nEachCurrent>=this.nEachMax?(this.nEachCurrent=0,this.currentN++):this.nEachCurrent++,1}}class BlobsPainter{constructor(t){this.n=t,this.currentN=0}draw(){if(this.currentN>=this.n)return 0;let[t,r]=randomFromRange(palettes[0]),s=fxRandRanged(100,xBufferSize-100),i=fxRandRanged(100,yBufferSize-100),n={u_size:.3+.4*fxrand()};return drawBlob(s,i,t,r,n),this.currentN++,1}}class PaperPainted{constructor(){this.isDrawn=!1}draw(){if(this.isDrawn)return 0;drawPaper(),this.isDrawn=!0}}class CircledBlobsPainter{constructor(t,r,s){this.x=t,this.y=r,this.n=s,this.nCurrent=0}draw(){if(this.nCurrent>=this.n)return 0;let t=fxRandRanged(0,2*Math.PI),r=fxRandRanged(0,yBufferSize)*fxrand()*fxrand()+200*fxrand(),[s,i]=getDecart(r,t);s+=this.x,i+=this.y;let[n,e]=randomFromRange(palettes[0]),h={u_size:fxRandRanged(.5,.6),u_radius:fxRandRanged(10,40),u_noise_multiplier:fxRandRanged(.3,.9)};return drawBlob(s,i,n,e,h),this.nCurrent++,1}}class SquarePainter{constructor(t,r,s,i,n){Object.assign(this,{colors:i,uniforms:n}),this.nCurrent=0,this.coords=[[t,r,t+s,r],[t+s,r,t+s,r+s],[t,r+s,t+s,r+s],[t,r,t,r+s]]}draw(){if(this.nCurrent>=this.coords.length)return 0;let t={...this.uniforms,u_seed:fxrand()};return drawCurve(...this.coords[this.nCurrent],...this.colors,t),this.nCurrent++,1}}class FilledSquarePainter extends NestedPainter{constructor(t,r,s,i,n,e,h){super();for(let a=0;a<n;a++){let n=new SquarePainter(t+i*a,r+i*a,s-2*i*a,e,h);this.painters.push(n)}}}class LinePainter{constructor(t,r,s,i,n,e){Object.assign(this,{x0:t,y0:r,x1:s,y1:i,colors:n,uniforms:e}),this.isDrawn=!1}draw(){return this.isDrawn||(drawCurve(this.x0,this.y0,this.x1,this.y1,...this.colors,this.uniforms),this.isDrawn=!0),0}}